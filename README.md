# WebRTC 入门指南

[TOC]

## 什么是 WebRTC

WebRTC（Web Real-Time Communication）是一套开放的浏览器或移动端实时通信技术与标准，让网页或 App 在不依赖插件的情况下，直接进行音视频通话、屏幕共享、以及点对点数据传输。

## 主要应用场景

- **视频会议**：Zoom、腾讯会议等企业协作和在线教育
- **社交通讯**：微信、WhatsApp 的音视频通话
- **实时直播**：低延迟直播、主播连麦互动
- **远程医疗**：在线问诊、远程会诊
- **智能监控**：智能门铃、家庭摄像头
- **云游戏**：游戏画面实时串流
- **P2P 传输**：浏览器间直接文件共享

## 核心特点

- **点对点通信（P2P）**：客户端之间直接传输数据，减少服务器中转，降低延迟和带宽成本
- **实时性**：端到端延迟低至 100-500ms，支持自适应码率、拥塞控制和抗丢包机制
- **安全性**：强制使用 DTLS-SRTP 加密，支持身份验证，浏览器级权限管理
- **跨平台支持**：主流浏览器原生支持，无需插件，提供移动端和多语言 SDK
- **开放标准**：由 W3C 和 IETF 制定的开放标准，Google 开源实现，互操作性强
- **NAT 穿透**：基于 ICE 框架集成 STUN/TURN 协议，在复杂网络环境下建立连接
- **丰富的媒体能力**：支持音视频采集、屏幕共享、多种编解码器、音频处理和数据通道
- **灵活的架构模式**：支持 Mesh、SFU、MCU 等多种拓扑结构，适应不同应用场景

## 网络基础知识

### NAT（Network Address Translation）网络地址转换

NAT 是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。

**NAT 的作用**

- **解决 IPv4 地址短缺问题**：允许多个设备共享一个公网 IP 地址
- **提供网络安全性**：内网设备通过 NAT 网关访问互联网，隐藏内网设备的真实 IP 地址，将私有网络与公共网络隔离

**NAT 的类型**

- **完全锥型 NAT（Full Cone）**：最宽松，一旦建立内网端口映射，任何外部主机都可以访问
- **受限锥型 NAT（Restricted Cone）**：只允许曾经通信过的 IP 地址访问
- **端口受限锥型 NAT（Port Restricted Cone）**：除了限制 IP，还限制端口
- **对称型 NAT（Symmetric）**：每个目标地址分配不同的外网端口，最严格，最难穿透

**NAT 穿透原理**

NAT 穿透的核心思想是让位于不同 NAT 后面的两个客户端能够直接通信，而不需要通过公网服务器中转数据。

**1. NAT 映射机制**

当内网设备向外网发送数据时，NAT 会创建一个映射表：

```
内网地址:端口 ↔ 公网地址:端口
192.168.1.100:5000 ↔ 1.2.3.4:50000
```

- NAT 会将内网私有地址转换为公网地址
- 外部响应数据包会通过此映射返回到内网设备
- 映射表有超时时间（通常 30 秒到几分钟）

**2. 打洞（Hole Punching）原理**

这是最常用的 NAT 穿透技术：

```
步骤 1：双方都向 STUN 服务器发送请求
客户端 A（内网 192.168.1.100:5000） → NAT-A → 公网 1.2.3.4:50000 → STUN 服务器
客户端 B（内网 10.0.0.100:6000） → NAT-B → 公网 5.6.7.8:60000 → STUN 服务器

步骤 2：STUN 服务器告知客户端各自的公网地址
STUN → A：你的公网地址是 1.2.3.4:50000
STUN → B：你的公网地址是 5.6.7.8:60000

步骤 3：通过信令服务器交换公网地址
A → 信令服务器 → B：我的公网地址是 1.2.3.4:50000
B → 信令服务器 → A：我的公网地址是 5.6.7.8:60000

步骤 4：双方同时向对方的公网地址发送数据包（关键步骤）
A → NAT-A（创建映射规则：内网A ↔ 5.6.7.8:60000）→ 5.6.7.8:60000
B → NAT-B（创建映射规则：内网B ↔ 1.2.3.4:50000）→ 1.2.3.4:50000

第一轮数据包可能都失败（被对方 NAT 丢弃）
  A 发的包 → NAT-B 丢弃 ❌
  B 发的包 → NAT-A 丢弃 ❌

第二轮数据包成功
  A 发的包(来自1.2.3.4:50000) → NAT-B（映射表中已有 B → 1.2.3.4:50000 的记录）→ 转发给 B ✅
  B 发的包(来自5.6.7.8:60000) → NAT-A（映射表中已有 A → 5.6.7.8:60000 的记录）→ 转发给 A ✅

步骤 5：NAT 打洞成功
- NAT-A 已经允许来自 5.6.7.8:60000 的入站流量
- NAT-B 已经允许来自 1.2.3.4:50000 的入站流量
- 双方可以直接 P2P 通信
```

**3. 不同 NAT 类型的穿透成功率**

| 对方 NAT 类型 | 完全锥型 | 受限锥型 | 端口受限锥型 | 对称型 |
|---|---|---|---|---|
| **完全锥型** | ✅ 100% | ✅ 100% | ✅ 100% | ⚠️ 部分 |
| **受限锥型** | ✅ 100% | ✅ 100% | ✅ 100% | ⚠️ 部分 |
| **端口受限锥型** | ✅ 100% | ✅ 100% | ✅ 100% | ⚠️ 部分 |
| **对称型** | ⚠️ 部分 | ⚠️ 部分 | ⚠️ 部分 | ❌ 失败 |

**4. 对称型 NAT 为什么难以穿透**

对称型 NAT 与其他 NAT 类型的核心区别：

```
锥型 NAT：
内网 192.168.1.100:5000 → 目标 A（8.8.8.8:80）
  ↓ 公网 1.2.3.4:50000
内网 192.168.1.100:5000 → 目标 B（9.9.9.9:80）
  ↓ 公网 1.2.3.4:50000 ← 端口相同 ✅

对称型 NAT：
内网 192.168.1.100:5000 → 目标 A（8.8.8.8:80）
  ↓ 公网 1.2.3.4:50000
内网 192.168.1.100:5000 → 目标 B（9.9.9.9:80）
  ↓ 公网 1.2.3.4:50001 ← 端口不同 ❌
内网 192.168.1.100:5000 → 目标 C（7.7.7.7:80）
  ↓ 公网 1.2.3.4:50002 ← 每个新目标的端口都不同 ❌
```

**穿透失败的详细过程：**

假设客户端 A 和客户端 B 都在对称型 NAT 后面，尝试建立 P2P 连接：

```
步骤 1：A 通过 STUN 获取公网地址
A（192.168.1.100:5000） → NAT-A → STUN 服务器
NAT-A 为这个连接分配：1.2.3.4:50000
STUN 告诉 A：你的公网地址是 1.2.3.4:50000

步骤 2：B 通过 STUN 获取公网地址
B（10.0.0.200:6000） → NAT-B → STUN 服务器
NAT-B 为这个连接分配：5.6.7.8:60000
STUN 告诉 B：你的公网地址是 5.6.7.8:60000

步骤 3：通过信令服务器交换地址
A 告诉 B：我的地址是 1.2.3.4:50000
B 告诉 A：我的地址是 5.6.7.8:60000

步骤 4：尝试打洞 —— 这里就出问题了！
A 尝试连接 B：A 向 5.6.7.8:60000 发送数据
  ↓ NAT-A 检测到新目标
  ↓ NAT-A 分配新端口：1.2.3.4:50002（不是 50000！）
  ↓ 数据包从 1.2.3.4:50002 到达 NAT-B
  ↓ NAT-B：没有规则允许来自 1.2.3.4:50002 的数据，数据包被丢弃 ❌

B 尝试连接 A：B 向 1.2.3.4:50000 发送数据
  ↓ NAT-B 检测到新目标
  ↓ NAT-B 分配新端口：5.6.7.8:60002（不是 60000！）
  ↓ 数据包从 5.6.7.8:60002 到达 NAT-A
  ↓ NAT-A：没有规则允许来自 5.6.7.8:60002 的数据，数据包被丢弃 ❌

结果：双方都无法收到对方的数据包！
```

**5. 穿透失败时的解决方案**

当 NAT 穿透失败时（特别是双方都是对称型 NAT），唯一可靠的方法是使用 TURN 服务器中继：

```
客户端 A ↔ TURN 服务器 ↔ 客户端 B
            ↑
所有数据通过 TURN 服务器转发，不需要 A 和 B 直接连接

优点：100% 成功率，兼容所有 NAT 类型
缺点：增加延迟，消耗服务器带宽
```

**6. WebRTC 中的自动穿透流程**

WebRTC 的 ICE 框架会**并行**尝试多种穿透方式：

1. 同时收集所有候选地址：
   - Host 候选（局域网直连）- 优先级：最高
   - Server Reflexive 候选（NAT 打洞）- 优先级：中
   - Relay 候选（TURN 中继）- 优先级：最低

2. 并发测试所有候选地址对
   - 不会等某个失败再尝试下一个
   - 采用“竞速”方式，同时测试所有可能的连接

3. 选择最优路径
   - 在所有成功的连接中，选择延迟最低、优先级最高的那个
   - 通常 P2P 直连会获胜（延迟低）
   - TURN 中继作为兜底方案保证 100% 连通

### ICE（Interactive Connectivity Establishment）交互式连接建立

ICE 是一种用于在复杂网络环境中建立点对点连接的框架协议。它通过收集多种候选连接地址，并系统地测试这些候选地址对之间的连通性，从而找到最优的通信路径。ICE 结合了 STUN 和 TURN 协议，能够智能地穿透各种类型的NAT和防火墙，优先选择直连方式以降低延迟，在直连失败时自动降级使用中继服务器，最终确保 WebRTC 等实时通信应用能够在互联网上可靠地建立连接。

**核心作用**

- WebRTC 的核心网络协议框架
- 负责在复杂网络环境中找到最优连接路径
- 整合 STUN 和 TURN 协议

**工作流程**

1. **收集候选地址（ICE Candidates）**
   - **Host 候选**：本地网络接口地址（局域网 IP）
   - **Server Reflexive 候选**：通过 STUN 获取的公网地址
   - **Relay 候选**：通过 TURN 服务器中继的地址

2. **连接检查（Connectivity Check）**
   - 双方交换候选地址
   - 对所有候选地址对进行连通性测试
   - 选择延迟最低、优先级最高的路径

3. **连接建立**
   - 优先选择 P2P 直连（低延迟、低成本）
   - 无法直连时使用 TURN 中继

### STUN（Session Traversal Utilities for NAT）NAT 会话穿透工具

STUN 是一种轻量级的网络协议，它的主要作用是帮助位于 NAT（网络地址转换）后面的设备发现自己的公网IP地址和端口映射关系。当客户端向 STUN 服务器发送请求时，服务器会将客户端的公网地址信息返回给它，使得客户端能够了解自己在互联网上的真实可达地址，从而可以将这个地址信息告知对等端，实现点对点的直接通信。

STUN 主要用于解决对称型 NAT 之外的 NAT 穿透问题，它成本低廉、响应快速，是 WebRTC 中 ICE 框架的重要组成部分，但在面对严格的防火墙或对称型 NAT 时，仍需要配合 TURN 服务器来确保连接的建立。

**功能**

- 帮助客户端发现自己的公网 IP 和端口
- 判断所处的 NAT 类型
- 实现 NAT 穿透

```
客户端 → STUN 服务器：我的公网 IP 是什么？
STUN 服务器 → 客户端：你的公网 IP 是 1.2.3.4:5678
```

**局限性**

- 对称型 NAT 无法穿透
- 某些企业防火墙会阻止
- 只能辅助发现地址，不提供中继

### TURN（Traversal Using Relays around NAT）中继 NAT 穿透

TURN 是一种基于中继服务器的 NAT 穿透解决方案，作为 WebRTC 连接建立的最后保障手段。当 STUN 无法穿透严格的 NAT 或防火墙（如对称型 NAT）导致点对点直连失败时，TURN 服务器会介入作为中间中继节点，接收来自通信双方的所有数据流量并进行转发。虽然这种方式会增加延迟和服务器带宽成本，但它能够确保在任何网络环境下都能建立连接，是 ICE 框架中可靠性的最终保证。

TURN 服务器通常需要认证机制来防止滥用，并且由于需要转发所有媒体流量，相比 STUN 服务器需要更强大的带宽和计算资源。

**功能**

- 当 P2P 无法建立时的备用方案
- 通过服务器中继数据

```
客户端 A ↔ TURN 服务器 ↔ 客户端 B
```

**特点**

- 兼容性好，可以穿透所有 NAT 类型
- 消耗服务器带宽和资源
- 延迟较高，成本较大
- 通常 10-20% 的连接需要 TURN

### SDP（Session Description Protocol）会话描述协议

SDP 是一种基于文本的协议格式，用于描述多媒体会话的各种参数和能力信息。

在 WebRTC 中，SDP 充当通信双方协商媒体传输细节的“说明书”，它包含了媒体类型（音频、视频、数据通道）、编解码器及其参数、网络传输地址（IP 和端口）、带宽要求、加密方式等关键信息。通信过程中，发起方创建 SDP Offer 描述自己支持的媒体能力和偏好，接收方返回 SDP Answer 表明自己的能力并选择双方都支持的配置，这种 Offer/Answer 模型使得两端能够就如何建立媒体流达成一致。虽然 SDP 格式较为复杂且不易阅读，但它是 WebRTC 信令交换的核心载体，确保了不同设备和浏览器之间能够准确理解对方的媒体能力并建立兼容的通信会话。

**SDP 包含的核心参数信息**

1. **会话级别信息**
   - 协议版本（v=）
   - 会话来源和标识（o=）
   - 会话名称（s=）
   - 会话时间（t=）

2. **媒体类型和传输协议**
   - 媒体类型（audio、video、application）
   - 传输协议（UDP/TLS/RTP/SAVPF）
   - 端口号和连接地址

3. **编解码器能力**
   - 支持的编解码器列表（VP8、VP9、H.264、Opus 等）
   - 编解码器参数（采样率、通道数、profile-level）
   - Payload 类型映射（rtpmap）

4. **网络连接信息**
   - ICE 候选地址（host、srflx、relay）
   - ICE 认证参数（ice-ufrag、ice-pwd）
   - 候选地址优先级

5. **安全和加密**
   - DTLS 指纹（fingerprint）
   - 加密协议（SRTP）
   - 密钥协商方式

6. **媒体流控制**
   - 媒体流标识（SSRC、CNAME）
   - 传输方向（sendrecv、sendonly、recvonly）
   - 多路复用配置（BUNDLE、rtcp-mux）

7. **服务质量（QoS）**
   - 带宽限制（b=）
   - RTCP 反馈机制（nack、pli、fir）
   - 拥塞控制扩展

**工作原理**

SDP 的工作基于 Offer/Answer 模型，具体流程：

**1. 发起方创建 Offer**

通信发起方生成一个 SDP Offer，描述自己支持的所有媒体能力：

- 支持的媒体类型（音频/视频/数据通道）
- 可用的编解码器列表（如 VP8、VP9、H.264、Opus 等）
- 媒体参数（分辨率、帧率、比特率）
- 网络传输信息（ICE 候选地址）
- 加密和安全参数

同时开始收集 ICE 候选地址，准备建立网络连接。

**2. 传输 Offer**

SDP Offer 通过信令服务器（WebSocket、HTTP 等）传输给接收方。

**3. 接收方创建 Answer**

接收方收到 Offer 后，分析双方能力并生成 SDP Answer：

- Answer 中只包含双方都支持的媒体能力（取交集）。确定最终使用的编解码器、分辨率等参数
- 例如，Offer 支持 VP8、H.264，Answer 支持 VP8、VP9，最终选择 VP8

**4. 传输 Answer**

SDP Answer 通过信令服务器返回给发起方，至此双方就媒体格式、编解码器、传输参数等达成一致。

**5. ICE 连接建立**

在 SDP 交换过程中，双方持续收集并交换 ICE 候选地址，通过 ICE 框架测试连通性，选择最优路径建立媒体传输通道。

**6. 开始媒体传输**

一旦网络连接建立成功，双方开始按照协商好的参数传输音视频数据，使用协商的编解码器进行编解码，并通过 SRTP 加密保护媒体流。

**核心要点**

- **Offer/Answer 顺序**：必须先 Offer 后 Answer，不能颠倒
- **能力协商**：最终使用的是双方能力的交集，确保兼容性
- **并行过程**：SDP 交换与 ICE 候选收集是并行进行的
- **Trickle ICE**：可以边收集 ICE 候选边交换，无需等待全部收集完成，加快连接速度

### 信令（Signaling）

信令是 WebRTC 通信中用于协调和建立对等连接的控制机制，它负责在两个或多个对等端之间交换必要的元数据信息，包括会话描述协议（SDP）中的媒体能力、编解码器、网络地址等信息，以及 ICE 候选（网络路径信息），使得双方能够协商出最佳的连接方式并建立起点对点的音视频或数据传输通道。

需要注意的是，WebRTC 本身并不定义信令的具体实现方式，开发者可以自由选择使用 WebSocket、HTTP、Socket.io 等任何通信协议来实现信令服务器和信令传输机制。

**常用实现方式**

- **WebSocket**：双向通信，最常用
- **HTTP 长轮询**：兼容性好但效率低
- **Socket.io**：封装良好的实时通信库
- **MQTT/XMPP**：适合物联网和即时通讯

**工作原理**

具体分为以下几个阶段：

**1. 连接信令服务器**

通信双方（Peer A 和 Peer B）在开始通信前，首先需要与信令服务器建立连接：

- 双方通过 WebSocket、HTTP 长轮询或其他协议连接到同一个信令服务器
- 信令服务器为每个连接的客户端分配唯一标识
- 双方通过某种方式（如房间号、用户ID）表明希望与哪个对等端通信
- 信令服务器维护客户端的在线状态和路由信息

**2. 发起方创建并发送 Offer**

Peer A 作为发起方启动通信流程：

- 获取本地媒体流（通过摄像头、麦克风获取音视频数据）
- 创建本地 PeerConnection 对象并添加媒体流
  - 为了告诉 PeerConnection 本地打算发送哪些媒体轨道（音频/视频）
  - 这是生成 SDP Offer 的前提，因为 Offer 需要描述这些媒体流的详细信息
- 生成 SDP Offer，描述自己的所有媒体轨道和能力
  - Offer 中会包含 Peer A 添加的所有媒体轨道（几路音频、几路视频，如：屏幕共享+摄像头）
  - 每个轨道列出 Peer A 支持的所有编解码器和传输参数
- 将生成的 SDP Offer 包装成信令消息
- 通过信令服务器发送给目标对等端 Peer B
- 信令服务器根据目标标识找到 Peer B 的连接，将 Offer 转发过去
- 同时，Peer A 开始收集 ICE 候选地址

**3. 接收方处理 Offer 并发送 Answer**

Peer B 从信令服务器接收到 SDP Offer：

- 信令服务器将 Offer 推送到 Peer B 的连接
- Peer B 接收并解析 SDP Offer，了解 Peer A 的媒体能力
- 创建本地 PeerConnection 对象
  - 如果 Peer B 也需要发送音视频（双向通信），则：
    - 获取本地媒体流并添加到 PeerConnection，告诉 PeerConnection 自己要发送哪些媒体轨道
  - 如果 Peer B 只接收不发送（单向通信，如观看直播），则：
    - 无需获取和添加本地媒体流，PeerConnection 会自动准备接收对方的媒体流
- 分析双方能力的交集，生成 SDP Answer
  - 如果 Peer B 添加了媒体流，Answer 会描述 Peer B 的所有媒体轨道（几路音频、几路视频，如：屏幕共享+摄像头、多摄像头同时传输）
  - 但每个轨道的编解码器只包含双方协商都支持的编解码器和参数，例如：Offer 支持 VP8、H.264，Peer B 支持 VP8、VP9，最终 Answer 中选择 VP8
  - **与 Offer 的区别**：Offer 列出所有支持的编解码器，而 Answer 只包含双方协商后都支持的编解码器（取交集）
- 将 SDP Answer 包装成信令消息
- 通过信令服务器发送回 Peer A
- 信令服务器接收后转发给 Peer A
- Peer B 也开始收集 ICE 候选地址

**4. 持续交换 ICE 候选**

SDP 交换完成后，双方开始通过信令服务器交换网络连接信息：

- Peer A 每收集到一个新的 ICE 候选地址，就立即发送给信令服务器
- 信令服务器将候选转发给 Peer B
- Peer B 同样将自己的 ICE 候选通过信令服务器发送给 Peer A
- 这个交换过程持续进行，直到双方都收集完所有候选（收到空候选）
- ICE 框架在后台并行测试所有候选地址对的连通性

**5. 建立点对点连接**

ICE 框架完成连通性测试后：

- 选择最优的网络路径（通常是延迟最低的路径）
- 在双方之间建立直接的点对点连接
- 连接建立成功后，音视频数据直接在 Peer A 和 Peer B 之间传输
- **媒体数据不再经过信令服务器**，大大降低了服务器负担

**6. 信令服务器的后续角色**

信令服务器作为中介的角色，信令通道通常保持开放，仅负责转发控制消息，不传输媒体数据：

- 处理重新协商请求（网络变化、添加/移除媒体流）
- 传递通话控制消息（静音、挂断、屏幕共享切换等）
- 处理连接质量通知和错误报告
- 在连接断开时协助重新建立连接

### 传输层协议

**UDP（User Datagram Protocol）用户数据报协议**

UDP 是一种无连接的传输层协议，作为 WebRTC 底层的首选传输协议。

主要特点包括：

- **无连接**：不需要在发送数据前建立连接
- **不可靠传输**：不保证数据包一定能到达目的地，也不保证顺序
- **速度快**：由于没有连接建立和确认机制，传输速度更快
- **开销小**：协议头部信息较少（仅8字节）

UDP 常用于对实时性要求高、但对可靠性要求相对较低的应用场景。

**SCTP（Stream Control Transmission Protocol）流控制传输协议**

SCTP 是一种传输层协议，作为 WebRTC DataChannel（数据通道）的核心协议。它结合了 TCP 和 UDP 的优点：

- **可靠传输**：像 TCP 一样保证数据可靠送达
- **消息边界**：像 UDP 一样保留消息边界，能否清楚地区分每条消息的开始和结束，使得传输结构化数据更加方便
- **多流支持**：支持多个独立的数据流，避免队头阻塞
- **多宿主**：可以同时绑定多个 IP 地址，故障自动切换，提高网络连接的可靠性和稳定性

WebRTC 使用 SCTP over DTLS over UDP 的方式来实现数据通道，用于在浏览器之间传输任意数据，如文本、文件等。

```
WebRTC 数据通道 → 使用 SCTP over DTLS over UDP
WebRTC 音视频 → 使用 RTP over UDP
```

**DTLS（Datagram Transport Layer Security）数据报传输层安全协议**

DTLS 是 TLS（Transport Layer Security）的变体，专门为**无连接协议**（如 UDP）设计的安全协议。

主要用途：

- **加密数据**：保护音视频和数据通道的内容
- **身份验证**：通过证书验证通信双方身份
- **密钥交换**：交换加密密钥，为 SRTP（音视频加密）提供密钥

```
数据通道   → SCTP → DTLS (加密) → UDP
音视频数据 → SRTP (加密) → UDP
```

DTLS 确保了即使在不可靠的 UDP 传输上，WebRTC 通信也是安全和私密的。

**SRTP（Secure Real-time Transport Protocol）安全实时传输协议**

SRTP 是 RTP（Real-time Transport Protocol，实时传输协议）的安全版本，为实时音视频流提供加密、消息认证和完整性保护。

主要用途：

- 加密的 RTP 协议
- 用于传输音视频数据
- 防止窃听和篡改

WebRTC 强制使用 SRTP 来传输音视频数据，确保音视频通话是私密和安全的，防止被窃听或篡改。

```
发送端：
音视频数据 → 编码 → RTP 打包 → SRTP 加密 → UDP 发送

接收端：
UDP 接收 → SRTP 解密 → RTP 解包 → 解码 → 音视频播放
```

### 网络质量适应

WebRTC 通过以下三种机制应对复杂的网络环境，确保实时通信的稳定性和流畅性。

- **拥塞控制**：主动检测网络，避免拥塞发生（预防性）
- **抗丢包机制**：处理已发生的丢包，恢复数据（补救性）
- **抖动缓冲**：消除网络抖动，保证播放流畅（平滑性）

#### 拥塞控制

GCC（Google Congestion Control）是 WebRTC 的核心拥塞控制算法，用于实时监测网络带宽和延迟变化，预防网络拥塞。

**核心目的**

- 最大化利用可用带宽，传输尽可能高质量的音视频
- 避免网络拥塞，防止丢包和延迟激增
- 快速适应网络变化，动态调整码率

**工作原理**

GCC 通过两种互补的方式持续评估网络状况：

1. **基于丢包的控制**（Loss-based）
   - 监测 RTCP 报告中的丢包率
   - 如果丢包率升高 → 可能是拥塞或网络质量差 → 降低发送码率
   - 如果丢包率低 → 说明网络良好 → 尝试提高码率

2. **基于延迟的控制**（Delay-based）
   - 通过接收端的到达时间间隔变化，计算延迟梯度
   - 如果延迟增加 → 网络队列积压 → 提前降低码率（拥塞迹象）
   - 如果延迟稳定 → 网络畅通 → 可以增加码率
   - **优势**：延迟增加是拥塞的早期信号，当网络开始拥塞时，数据包会在路由器队列中排队等待，导致延迟上升。此时丢包可能还未发生，但如果不及时降低码率，队列溢出后就会开始大量丢包。因此，基于延迟的控制更敏感，能在丢包前预判拥塞与提前干预。

**码率调整策略**

```
网络状态评估 → 计算目标码率 → 通知编码器调整

检测到拥塞迹象：
当前码率 1Mbps → 降低 15% → 新码率 850Kbps → 编码器降低视频质量

网络状况改善：
当前码率 850Kbps → 缓慢增加 5% → 新码率 892Kbps → 编码器提高视频质量
```

- **快速降低**：检测到拥塞立即降低码率（0.8-0.85倍），避免雪崩
- **谨慎增加**：网络改善时缓慢提升码率（1.03-1.08倍），避免再次拥塞
- **持续监测**：每秒评估多次，保持快速响应

**实际场景**

示例场景：用户在进行视频通话的同时开始下载任务。

```
时刻 0s：码率 2Mbps，丢包率 0.5%，延迟 50ms → 视频质量优秀
时刻 1s：延迟增加到 80ms（+60%），丢包率仍为 0.8% → GCC 检测到拥塞迹象
时刻 2s：快速降低码率至 1.6Mbps → 编码器降低分辨率或帧率
时刻 3s：延迟稳定在 70ms，丢包率 0.6% → 拥塞缓解
时刻 5s：下载任务完成，网络恢复 → 延迟降至 55ms → GCC 逐步提升码率至 1.9Mbps
时刻 10s：网络持续良好，延迟稳定 50ms → 码率恢复到 2Mbps → 视频质量恢复
```

这种动态调整机制保证了即使在网络波动时，通话仍然可以继续，只是会暂时降低视频质量，而不是完全卡住。

#### 抗丢包机制

网络丢包时的三种应对策略：

**FEC（Forward Error Correction）前向纠错**

- **原理**：发送时额外附加 10-20% 的冗余数据
- **优势**：接收端可直接恢复丢失的包，无需等待重传，延迟最低
- **劣势**：增加带宽占用
- **适用**：丢包率高、对延迟敏感的场景（如视频会议）

**NACK（Negative Acknowledgement）重传请求**

- **原理**：接收端发现丢包后，向发送端请求重传特定包
- **优势**：只在丢包时才占用额外带宽，效率高
- **劣势**：等待重传会增加延迟（通常 50-200ms）
- **适用**：网络相对稳定、可容忍轻微延迟的场景

**PLC（Packet Loss Concealment）丢包隐藏**

- **原理**：音频包丢失时，不等待重传，而是通过算法"补偿"缺失内容
- **技术手段**：
  - 插值：根据前后音频数据平滑过渡
  - 重复：复制上一帧音频内容
  - 合成：基于音频模式生成填充
- **优势**：避免明显的静音、杂音或断断续续
- **适用**：专门用于音频流，保证听感连续性

#### 抖动缓冲（Jitter Buffer）

数据包在网络中传输时，到达时间间隔不均匀。例如，理想情况下每 20ms 到达一个包，实际可能是 10ms、35ms、15ms 不规律到达。

主要作用：

```
接收数据包 → 缓存排序 → 恒定速率播放

出现网络抖动时，数据包到达的时间间隔不规律，序号顺序错乱。此时，先放入缓冲区等待排序。

收到包序号：1(0ms) → 4(25ms) → 2(30ms) → 3(35ms)
缓冲区排序：1 → 2 → 3 → 4
恒定播放：1(50ms) → 2(70ms) → 3(90ms) → 4(110ms)
```

1. **缓存接收的数据包**：将到达的包暂存在缓冲区
2. **重新排序**：按照序列号正确排列
3. **平滑播放**：以恒定的时间间隔取出数据播放

缓冲区大小选择：

- **缓冲区过小**：
  - 优点：延迟低（实时性好）
  - 缺点：来不及接收就要播放，容易卡顿
- **缓冲区过大**：
  - 优点：播放流畅，抗抖动能力强
  - 缺点：延迟高（实时性差）

WebRTC 会根据网络抖动程度动态调整缓冲区大小，通常：

- 音频：20-100ms
- 视频：50-200ms
